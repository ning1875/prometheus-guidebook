



#  <font color=red> 大运维平台5大模块</font>
- 01 资产管理 & cmdb & 服务树
- 02 工单 & 工作流 & 审批
- 03 cicd 全流程配置  ： 比较发怵，
- 04 Prometheus管理配置 ：没写过平台：想法
- 05 k8s多集群管理 ：vue2 课程，有丰富的经验：


【5】Prometheus 第1章 前置准备工作和Prometheus基础使用
【5】Prometheus 第2章 监控采集模块的开发规划
【5】Prometheus 第3章 监控采集模块之采集池
【5】Prometheus 第4章 监控采集模块之采集job设计和后端代码
【5】Prometheus 第5章 监控采集模块缓存生成分片配置
【5】Prometheus 第6章 监控采集模块支持k8s集群外采集
【5】Prometheus 第7章 监控采集模块前端采集池
【5】Prometheus 第8章 监控采集模块前端采集任务
【5】Prometheus 第9章 测试联调
【5】Prometheus 第10章 告警模块alertmanager基础
【5】Prometheus 第11章 告警模块分组的后端逻辑
【5】Prometheus 第12章 告警规则触发和sendgroup的关联
【5】Prometheus 第13章 本地mock从采集-告警-分组-webhook
【5】Prometheus 第14章 值班表逻辑
【5】Prometheus 第15章 值班表历史和换班记录
【5】Prometheus 第16章 webhook后端处理程序基础
【5】Prometheus 第17章 webhook后端处理程序
【5】Prometheus 第18章 im的机器人
【5】Prometheus 第19章 交互式卡片消息
【5】Prometheus 第20章 webhook根据卡片模板生成消息01    
【5】Prometheus 第21章 webhook根据卡片模板生成消息02
【5】Prometheus 第22章 屏蔽和认领接口
【5】Prometheus 第23章 私聊和群聊token获取
【5】Prometheus 第24章 前端编写之值班组
【5】Prometheus 第25章 前端编写之值班组排班
【5】Prometheus 第26章 换班逻辑
【5】Prometheus 第27章 alertmanager集群管理
【5】Prometheus 第28章 发送组配置管理
【5】Prometheus 第29章 告警规则前端配置
【5】Prometheus 第30章 告警规则配置后端接口
【5】Prometheus 第31章 告警规则annotation默认添加description_value
【5】Prometheus 第32章 告警事件管理


# 【模块5】Prometheus监控管理平台
- 第1章 前置准备工作和Prometheus基础使用
  - 1.1 为什么先开发Prometheus
  - 1.2 普罗平台都要做哪些模块
  - 1.3 梳理一下每个模块平台侧功能
  - 1.4 初始化ansible做准备
  - 1.5 playbook批量部署node-exporter
  - 1.6 部署Prometheus后介绍基础功能
  - 1.7 部署grafana
  - 1.8 配置采集node-exporter

- 第2章 监控采集模块的开发规划
  - 2.1 采集之exporter管理规划
  - 2.2 采集job通用配置规划
  - 2.3 采集配置和Prometheus文件的管理
  - 2.4 采集完的传输规划
  - 2.5 安装VictoriaMetrics
  - 2.6 remote-write到vm并查询
  - 2.7 采集器高可用问题
  - 2.8 hashmod和服务发现配置
  - 2.9 动态分片和静态分片
  - 2.10 总结一下采集模块开发规划

- 第3章 监控采集模块之采集池
  - 3.1 准备prometheus代码
  - 3.2 实验scrape_config_files
  - 3.3 后端go文件tbl和view加模块前缀
  - 3.4 采集池的字段
  - 3.5 采集池和Prometheus节点的关系
  - 3.6 mock采集池数据
  - 3.7 构建采集池生缓存
  - 3.8 根据采集池生成Prometheus主配置文件-01
  - 3.9 组装主配置逻辑
  - 3.10 进行测试

- 第4章 监控采集模块之采集job设计和后端代码
  - 4.1 生成主配置文件和http合并一起
  - 4.2 编写download脚本测试api接口
  - 4.3 http类型的服务发现
  - 4.4 采集job表结构适配http类型的服务发现
  - 4.5 服务树http类型sd接口数据准备
  - 4.6 服务树http类型sd接口拼接targetGroup
  - 4.7 测试服务树http-sd接口
  - 4.8 http-sd和采集联调成功
  - 4.9 添加获取所有叶子节点fullPath和Id的接口
  - 4.10 生成主配置文件添加采集job准备

- 第5章 监控采集模块缓存生成分片配置
  - 5.1 生成http-sd的配置项
  - 5.2 cache合入主配置文件
  - 5.3 解决http接口不显示scrape问题
  - 5.4 服务树mock绑定ecs差异化
  - 5.5 分片之tmpHash-keep
  - 5.6 验证单一ip和分片的结果
  - 5.7 采集器健康检测问题

- 第6章 监控采集模块支持k8s集群外采集
  - 6.1 k8s的采集方式并部署inCluster采集
  - 6.2 模拟集群外采集解决证书x509问题
  - 6.3 模拟集群外采集解决401-token问题
  - 6.4 集群外采集数据库字段
  - 6.5 统计开发数据
  - 6.6 测试ca和token直接填内容
  - 6.7 解决不能使用inline-CA问题
  - 6.8 kubeconfig可不可以去掉
  - 6.9 解决kubeconfig_file和sd的http-client冲突问题
  - 6.10 尝试添加relabel_configs的支持

- 第7章 监控采集模块前端采集池
  - 7.1 准备菜单
  - 7.2 采集池的表格和list接口
  - 7.3 表格字段和标签颜色
  - 7.4 新增采集池的表单
  - 7.5 机器apiSelect
  - 7.6 调整表单字段宽度
  - 7.7 切割exteralLabels前后端适配
  - 7.8 实例ip字段适配并mock2个真实节点
  - 7.9 remoteWrite地址url校验
  - 7.10 后端接口新增和更新接口
  - 7.11 查看采集实例的yaml
  - 7.12 yaml查看的后端接口支持鉴权和非鉴权
  - 7.13 codemirror展示yaml并添加复制按钮

- 第8章 监控采集模块前端采集任务
  - 8.1 准备菜单
  - 8.2 删除采集池和采集池ip不能和其他池重复
  - 8.3 采集任务表格和list接口
  - 8.4 新增采集任务控制不同服务发现类型
  - 8.5 新增采集任务支持http服务发现
  - 8.6 新增采集任务调整form格式
  - 8.7 编辑任务时http-sd绑定的树节点名称只显示id问题
  - 8.8 定位到ids数组的问题
  - 8.9 模仿stringArray在gorm中做IntArr
  - 8.10 模仿stringArray在gorm中做IntArr

- 第9章 测试联调
  - 9.1 测试采集池缩容情况
  - 9.2 测试采集池扩容解决指针数组问题
  - 9.3 测试k8s采集任务发现relabel缩进问题
  - 9.4 通过规定解决索引问题
  - 9.5 api中添加relabel解析失败的校验 
  - 9.6 测试k8s的job解决时间大小问题 
  - 9.7 模拟真实应用场景之cron 
  - 9.8 给任务添加开关 
  - 9.9 模拟部分job关闭情况=0不更新 

- 第10章 告警模块alertmanager基础
  - 10.1 告警TODO
  - 10.2 alertmanager核心功能点介绍和安装部署
  - 10.3 编写go程序充当告警触发端和接收端
  - 10.4 alertmanager分组功能-01
  - 10.5 alertmanager分组功能-02
  - 10.6 告警抑制实例
  - 10.7 告警静默

- 第11章 告警模块分组的后端逻辑
  - 11.1 分析alertmanager配置
  - 11.2 alert实例对象
  - 11.3 send_group对象
  - 11.4 静态人和升级的关系
  - 11.5 生成mainconfig的逻辑
  - 11.6 准备group的mock数据
  - 11.7 校验默认route的生成
  - 11.8 newMatcher匹配
  - 11.9 验证match-re和route的生成
  - 11.10 生成对应的receiver

- 第12章 告警规则触发和sendgroup的关联
  - 12.1 定义规则表rule字段
  - 12.2 缓存AlertManager生成yaml的逻辑
  - 12.3 测试yaml的结果
  - 12.4 告警触发复用采集池
  - 12.5 生成Prometheus主配置时需要添加alert的支持
  - 12.6 进行测试
  - 12.7 ruleFormat拼接规则
  - 12.8 生成单一规则
  - 12.9 如何直接生成group-go对象
  - 12.10 编写rule规则分片逻辑

- 第13章 本地mock从采集-告警-分组-webhook
  - 13.1 测试rule分片的逻辑
  - 13.2 给规则中添加send_group标签
  - 13.3 本地mock从采集-告警-分组-webhook之采集数据准备
  - 13.4 本地mock从采集-告警-分组-webhook之采集数据完整链路验证
  - 13.5 总结TODO

- 第14章 值班表逻辑
  - 14.1 基础逻辑
  - 14.2 表结构的设计
  - 14.3 思考交互逻辑
  - 14.4 mock数据并准备api
  - 14.5 最小化模拟轮班过程-1
  - 14.6 最小化模拟轮班过程-2
  - 14.7 查询历史值班情况
  - 14.8 mock集合历史算出未来
  - 14.9 进行测试
  - 14.10 完成api中未来的逻辑

- 第15章 值班表历史和换班记录
  - 15.1 测试api发现边界问题
  - 15.2 解决这个问题
  - 15.3 值班换班记录表和历史表关系
  - 15.4 ticker填充历史记录
  - 15.5 解决多对多映射问题
  - 15.6 解决结束日期边界问题
  - 15.7 mock一些历史数据
  - 15.8 又发现bug了
  - 15.9 最终解决边界问题
  - 15.10 给值班组绑定查询当前值班人的方法

- 第16章 webhook后端处理程序基础
  - 16.1 webhook处理程序的核心功能和是否独立
  - 16.2 webhook解析配置-连接数据库
  - 16.3 整理各模块gin的route和view目录
  - 16.4 启动接受alert的接口
  - 16.5 测试接收alert
  - 16.6 receive接口把alert异步写入Queue
  - 16.7 消费alertQueue的框架
  - 16.8 启动消费者并测试
  - 16.9 【7模块golang大运维平台】【模块5 Prometheus监控】【开发Webhook告警处理模块】为何要构建SendGroup的cache
  - 16.10 renewMap之SendGroup的逻辑

- 第17章 webhook后端处理程序
  - 17.1 如何保证接口在缓存刷新后启动-goroutine的顺序控制
  - 17.2 消费者需要根据id获取发送组信息
  - 17.3 类比sg把用户和值班组的缓存也构建出来
  - 17.4 进行测试
  - 17.5 设计告警event表
  - 17.6 在alert中获取ruleId
  - 17.7 构建rule规则的cache
  - 17.8 尝试event的save操作
  - 17.9 event的次数更新

- 第18章 im的机器人
  - 18.1 im选择飞书
  - 18.2 了解飞书机器人
  - 18.3 自定义机器人发送消息
  - 18.4 userId-openId如何获取
  - 18.5 自定义机器人其他格式消息
  - 18.6 应用机器人私聊消息
  - 18.7 总结机器人消息发送和tenant_access_token获取
  - 18.8 测试给二狗发送消息失败 机器人的可见范围

- 第19章 交互式卡片消息
  - 19.1 卡片消息和 消息卡片搭建工具
  - 19.2 自定义机器人发送卡片消息 
  - 19.3 应用机器人发送卡片消息 
  - 19.4 消息卡片搭建工具构造告警信息模板01 
  - 19.5 消息卡片搭建工具构造告警信息模板emoji
  - 19.6 消息卡片搭建工具构造告警信息模板按钮组
  - 19.7 消息卡片搭建工具构造告警信息模板发送测试

- 第20章 webhook根据卡片模板生成消息01    
  - 20.1 构造基础json模板
  - 20.2 封装http请求基础库post
  - 20.3 实验拼接大json部分字段
  - 20.3 群聊和私聊复用拼接大json的逻辑
  - 20.4 测试私聊卡片
  - 20.5 解决私聊卡片问题
  - 20.6 拼接卡片消息之绑定服务树和级别
  - 20.7 如何获取value
  - 20.8 进行字段的拼接之标题颜色
  - 20.9 拼接绑定服务树和时间
  - 20.10 调整一下mock数据


- 第21章 webhook根据卡片模板生成消息02
  - 21.1 grafana链接和expr规则
  - 21.2 拼接发送组
  - 21.3 拼接屏蔽和认领按钮
  - 21.4 取消屏蔽
  - 21.5 获取值班人和值班组
  - 21.6 解决TodayDutyUser为空问题
  - 21.7 测试at不同人
  - 21.8 告警升级的私聊对象变为数组
  - 21.9 拼接升级内容并切换发送人
  - 21.10 mock数据告警升级接收人列表并测试

- 第22章 屏蔽和认领接口
  - 22.1 测试告警升级格式
  - 22.2 补全告警标签和annotation
  - 22.3 私聊发给值班人+发送告警群at值班人
  - 22.4 告警屏蔽接口
  - 22.5 测试告警屏蔽
  - 22.6 取消屏蔽接口event增加silenceId
  - 22.7 完成unsilence接口
  - 22.8 按alertName屏蔽按钮
  - 22.9 按alertName屏蔽接口

- 第23章 私聊和群聊token获取
  - 23.1 完成群聊发送token设置
  - 23.2 私聊token刷新管理器
  - 23.3 测试私聊token

- 第24章 前端编写之值班组 
  - 24.1 增加菜单
  - 24.2 值班组列表数据
  - 24.3 值班组Form字段
  - 24.4 值班组新增和更新
  - 24.5 值班组删除保护和级联删除
  - 24.6 route-link实现表格跳转
  - 24.7 准备排班表页面
  - 24.8 调试排班页面之moment获取日期
  - 24.9 和后端值班表对应上
  - 24.10 panelChange查看其他月份

- 第25章 前端编写之值班组排班展示
  - 25.1 排班计划时间范围分3种情况
  - 25.2 排班组详情页增加信息
  - 25.3 轮班周期的填充历史记录的逻辑
  - 25.4 进行测试
  - 25.5 如果昨天的人是换班的-那么就得用它之前的人
  - 25.6 第一轮剩余轮班逻辑
  - 25.7 第一轮超过的逻辑
  - 25.8 测试第一轮剩余
  - 25.9 测试第一轮超过
  - 25.10 前段获取周期默认为2个月

- 第26章 换班逻辑
  - 26.1 点击日期打开模态框
  - 26.2 需要把日期原值班人传入
  - 26.3 完成换班请求拼接
  - 26.4 后端接口测试并添加换班记录
  - 26.5 换班的记录显示在日历上
  - 26.6 历史日期不能换班
  - 26.7 测试历史换班记录

- 第27章 alertmanager集群管理
  - 27.1 发送组菜单
  - 27.2 alertmanager集群列表
  - 27.3 alert集群yaml查看页面
  - 27.4 新增alertmanager集群的drawer
  - 27.5 新增接口和ip重复检验
  - 27.6 更新删除接口

- 第28章 发送组配置管理
  - 28.1 发送组表格字段
  - 28.2 发送组列表接口
  - 28.3 展示第一升级人列表
  - 28.4 发送组的基础form字段
  - 28.5 告警升级开关
  - 28.6 封装view中公共的获取用户方法
  - 28.7 告警升级人编辑展示
  - 28.8 发送组的新增和更新接口
  - 28.9 之前配置的升级人不配置了需要增量删除
  - 28.10 测试gorm事务型更新方法
  - 28.11 删除后reload表格
  - 28.12 发送组变更后alertmanager配置测试

- 第29章 告警规则前端配置
  - 29.1 菜单和规则表格字段
  - 29.2 fullfill方法和routeLink跳转
  - 29.3 告警级别颜色展示和开启switch
  - 29.4 规则的基础字段
  - 29.5 采集池要支持alertmanager配置
  - 29.6 标签和annotation列表字段
  - 29.7 promql-ui调研
  - 29.8 promql-ui配置
  - 29.9 ql和form位置调整
  - 29.10 promql语法校验的后端接口-1
  - 29.11 promql语法校验的后端接口-2
  - 29.12 校验都以200返回用字段区分

- 第30章 告警规则配置后端接口
  - 30.1 编辑的时候把expr回填
  - 30.2 定义前转后和后转前的模板方法
  - 30.3 code为空保护接口中校验ql
  - 30.4 drawer的closefunc刷新表格或页面
  - 30.5 告警规则的开关按钮
  - 30.6 告警规则的删除
  - 30.7 开关和删除能否批量操作
  - 30.8 开关批量操作的后端接口
  - 30.9 批量删除按钮
  - 30.10 采集池支持采集器规则和告警规则查看

- 第31章 告警规则annotation默认添加description_value
  - 31.1 告警规则yaml查看页面
  - 31.2 调整一下告警模块的菜单顺序
  - 31.3 告警规则annotation默认添加description_value
  - 31.4 解决rule文件中的非法字符
  - 31.5 人员信息添加飞书userId字段
  - 31.6 部分修补操作

- 第32章 告警事件管理
  - 32.1 菜单-页面-api文件
  - 32.2 mock一些数据
  - 32.3 status颜色展示和关联字段跳转
  - 32.4 第一次告警时间
  - 32.5 告警屏蔽接口
  - 32.6 如何通过event获取alm-api
  - 32.7 前端屏蔽按钮
  - 32.8 解析屏蔽时间
  - 32.9 已屏蔽的不能再有屏蔽按钮了
  - 32.10 封装通过event发送飞书群消息的公共方法

- 第33章 告警认领
  - 33.1 动作后同步触发im通知
  - 33.2 进行测试
  - 33.3 告警认领的webhook逻
  - 33.4 告警认领的接口
  - 33.5 告警认领的im消息拼接
  - 33.6 排查告警认领不能被告警升级覆盖
  - 33.7 排查renlingUserId=0
  - 33.8 解除屏蔽
  - 33.9 批量操作抽象公共方法
  - 33.10 前端进行batch和single的区分
  - 33.11 批量屏蔽的测试


- 第34章 record预聚合
  - 34.1 record基础知识和vm-remote-read
  - 34.2 实验record
  - 34.3 record复用采集池逻辑
  - 34.4 拆分cache中的几把锁
  - 34.5 mock预聚合规则并测试缓存
  - 34.6 完成同步record脚本
  - 34.7 采集池支持Record配置和查看
  - 34.8 配置预聚合规则列表
  - 34.9 创建和更新操作
  - 34.10 删除和批量删除
  - 34.11 Prometheus管理平台开发之告警和预聚合规则绑定服务树节点的应用


- 第35章 Prometheus告警总结
  - 35.1 总结采集模块
  - 35.2 总结值班组和ALertmanager模块
  - 35.3 总结webhook和im卡片消息模块
  - 35.4 总结告警规则模块


【5】Prometheus 第33章 告警认领
【5】Prometheus 第34章 record预聚合
【5】Prometheus 第35章 Prometheus告警总结

- 告警认领 屏蔽 动作
- TODO 批量屏蔽
- 告警事件 时间轴

- 采集任务对于采集池 相当于发送组 对于alert集群



- userId 小乙 6d31gdf4
- userId 二狗 38g18781
- openId 小乙 ou_9bc428cd87404206b209769e688516a9
- openId 二狗 ou_b545ecc25c20067c00078cb50e47cc14


飞书 群机器人发送卡片消息 https://open.feishu.cn/document/client-docs/bot-v3/add-custom-bot#%E6%94%AF%E6%8C%81%E5%8F%91%E9%80%81%E7%9A%84%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E
- 类似 formDesign的 卡片构造器 https://open.feishu.cn/tool/cardbuilder?templateId=ctp_AAVM3vG7x7tC 

- 前端
- im卡片
- webhook处理
- 值班表

  

# 采集管理
## 01 采集job管理 拼接Prometheus配置文件
- 总的逻辑就是引用 Prometheus config 包生成yaml文件 reload
- 样例文件C:\go_path\src\github.com\prometheus\prometheus\config\config_test.go
- 创建采集的job 添加 ip+port+/metrics-path的采集器
  - job名称
  - metrics-path
  - 端口
  -
- 然后绑定服务树，找到机器列表
- 查看实例代表：服务发现 + 写死ip的机器列表
- 多个采集Prometheus 分片的逻辑
  - 写http sd接口
  - 根据采集实例的ip 和当前存活实例做 分片



# 告警模块设计
- 告警分组匹配 的逻辑依赖 alertmanager match
```shell
global:
  resolve_timeout: 30m

route:
  group_by: ['alertname']
  group_wait: 5s
  group_interval: 5s
  repeat_interval: 1h
  receiver: 'sre_all'
  routes:                                       #子路由，父路由的所有属性都会被子路由继承
    - match_re:                                   #此路由在警报标签上执行正则表达式匹配，以捕获与服务列表相关的警报
        job: node_exporter
      receiver: sre_system
      # continue=true 代表继续向下匹配，不然就break了
      continue: true
    - match_re:
        job: mysqld_exporter
      receiver: sre_dba
      continue: true
      # 默认all路由
    - match_re:
        job: .*
      receiver: sre_all
      continue: true


receivers:
- name: 'sre_system'
  webhook_configs:
  - url: 'http://127.0.0.1:5001/alert'
- name: 'sre_dba'
  webhook_configs:
  - url: 'http://127.0.0.1:5002/alert'
- name: 'sre_all'
  webhook_configs:
  - url: 'http://127.0.0.1:5003/alert'
```

- 可以造一个标签：send_group alarm_key 对应1个id ，而后在alertmanager中 通过这个进行 匹配发给不同的人


## webhook处理的组件处理发送策略
- 告警匹配 的规则 key：等于是在告警规则中直接选择 发送策略：不过实现是通过 一个人造标签做的
- 发送值班组 at当天值班人
- 消息通知通道
- 生产告警内容
- 而且有必要 写一个webhook处理的组件
- 做值班表匹配
- 告警升级逻辑
- 存储告警到数据库中
- 处理 交互式卡片中的 告警认领和 告警屏蔽请求

# 排班组逻辑
- 历史真实每天值班人
- 轮班表 值班人数组，周期，当前到谁了的index：用于生产后面周期的值班人

# 统计

| 统计对象               | 统计方法                                   | 统计结果                                                                                                                                                           |                        |
|--------------------|----------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------|
| 后端golang代码行数       | `find -name "*.go" \| xargs wc -l`     | <font color=red> 截止模块[5/7] 2万2千</font> ![img_1.png](img_1.png)                                                                                                 |   |
| 前端vue3+ts代码行数(含框架) | `find \|egrep "*.vue*.ts"  \|xargs wc` | 截止模块[5/7] 41万 ![img_2.png](img_2.png)                                                                                                                          |
| mysql表             | `mysql> use bigdevops;show tables;`    | <font color=red> 截止模块[5/7] 37张</font>  ![img_3.png](img_3.png)                                                                                                 |
| 视频数量截止模块5-811      | 数量                                     | 模块01底座-137 <br>  模块02-服务树-123 <br>  模块03-工单-140 <br> 模块04-grpc-agent-148 <br> 模块05-prometheus[开发中]-253 <br> 模块06-k8s<br> <br> 模块07-cicd<br> <br> 模块08-?日志?<br> | 
| 技术栈                | 枚举                                     | gorm、prometheus、分片、grpc、vue3、k8s、cicd、formDesign等等                                                                                                             | 
| 学习要求               | 枚举                                     | <font color=green> 前端0基础+golang脚本能力即可 ！！只要你有决心，就可以</font>                                                                                                      | 

